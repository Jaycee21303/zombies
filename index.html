<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Temple Run – Mini Clone</title>
  <style>
    :root {
      color-scheme: dark;
      --lane-color: #252836;
      --lane-divider: #444a5f;
      --accent: #ffd166;
      --danger: #ef476f;
      --sky: linear-gradient(180deg, #0d1b2a 0%, #1b263b 30%, #2c3e50 100%);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: var(--sky);
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      color: #e6edf3;
      overflow: hidden;
    }

    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 12px 14px;
      background: rgba(10, 12, 20, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
      line-height: 1.4;
      backdrop-filter: blur(6px);
      pointer-events: none;
    }

    #hud h1 {
      margin: 0 0 6px;
      font-size: 18px;
      letter-spacing: 0.3px;
    }

    #hud p {
      margin: 2px 0;
      font-size: 14px;
    }

    #game {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #toast {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 14px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      font-size: 14px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="hud">
    <h1>Temple Run – Mini Clone</h1>
    <p id="score">Score: 0</p>
    <p id="status">Auto-running. Use ←→ / swipe to change lanes, ↑ / swipe up to jump, R to restart.</p>
  </div>
  <div id="toast">Stay alive and keep running!</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const statusEl = document.getElementById('status');
    const toast = document.getElementById('toast');

    const state = {
      running: true,
      gameOver: false,
      speed: 320,
      distance: 0,
      laneCount: 3,
      lanes: [],
      player: {
        lane: 1,
        x: 0,
        y: 0,
        vy: 0,
        width: 42,
        height: 70,
        jumpForce: 520,
        gravity: 1600,
        color: '#06d6a0'
      },
      obstacles: [],
      coins: [],
      spawnTimer: 0,
      coinTimer: 0,
      lastTime: performance.now(),
      touchStart: null,
      lastInputTime: 0,
    };

    const resize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const laneWidth = Math.min(140, canvas.width / (state.laneCount + 0.6));
      const centerX = canvas.width / 2;
      state.lanes = Array.from({ length: state.laneCount }, (_, i) => centerX + (i - 1) * laneWidth);
    };

    const resetGame = () => {
      state.running = true;
      state.gameOver = false;
      state.speed = 320;
      state.distance = 0;
      state.player.lane = 1;
      state.player.y = 0;
      state.player.vy = 0;
      state.obstacles = [];
      state.coins = [];
      state.spawnTimer = 0;
      state.coinTimer = 0;
      state.lastInputTime = performance.now();
      toast.textContent = 'Stay alive and keep running!';
      statusEl.textContent = 'Auto-running. Use \u2190\u2192 or swipe to change lanes, \u2191 / swipe up to jump, R to restart.';
      state.lastTime = performance.now();
      requestAnimationFrame(loop);
    };

    const spawnObstacle = () => {
      const lane = Math.floor(Math.random() * state.laneCount);
      const width = 70;
      const height = 60 + Math.random() * 60;
      state.obstacles.push({
        lane,
        y: -height - 30,
        width,
        height,
        color: Math.random() > 0.6 ? '#f3722c' : '#ef476f',
      });
    };

    const spawnCoin = () => {
      const lane = Math.floor(Math.random() * state.laneCount);
      state.coins.push({ lane, y: -20, size: 26, spin: 0 });
    };

    const nudgeLane = (delta) => {
      state.player.lane = Math.min(Math.max(0, state.player.lane + delta), state.laneCount - 1);
      state.lastInputTime = performance.now();
    };

    const jump = () => {
      if (state.player.y === 0) {
        state.player.vy = -state.player.jumpForce;
        state.lastInputTime = performance.now();
      }
    };

    const handleInput = (event) => {
      if (event.repeat) return;
      const key = event.key.toLowerCase();
      if (event.key === 'ArrowLeft' || key === 'a') {
        nudgeLane(-1);
      } else if (event.key === 'ArrowRight' || key === 'd') {
        nudgeLane(1);
      } else if (event.key === 'ArrowUp' || event.key === ' ' || key === 'w') {
        jump();
      } else if (key === 'r') {
        resetGame();
      }
    };

    const handleTouchStart = (e) => {
      if (!e.touches || e.touches.length === 0) return;
      const touch = e.touches[0];
      state.touchStart = { x: touch.clientX, y: touch.clientY, time: performance.now() };
    };

    const handleTouchEnd = (e) => {
      if (!state.touchStart) return;
      const touch = e.changedTouches[0];
      const dx = touch.clientX - state.touchStart.x;
      const dy = touch.clientY - state.touchStart.y;
      const dt = performance.now() - state.touchStart.time;
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      const fastSwipe = dt < 350 && (absX > 30 || absY > 30);

      if (fastSwipe) {
        if (absX > absY) {
          nudgeLane(dx > 0 ? 1 : -1);
        } else if (dy < -20) {
          jump();
        }
      } else if (state.gameOver) {
        resetGame();
      }

      state.touchStart = null;
    };

    document.addEventListener('keydown', handleInput);
    document.addEventListener('touchstart', handleTouchStart, { passive: true });
    document.addEventListener('touchend', handleTouchEnd, { passive: true });
    window.addEventListener('resize', resize);

    const drawLanes = () => {
      const laneWidth = state.lanes[1] - state.lanes[0];
      const pad = laneWidth * 0.42;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < state.laneCount; i++) {
        const x = state.lanes[i];
        ctx.fillStyle = i % 2 === 0 ? 'rgba(255,255,255,0.02)' : 'rgba(255,255,255,0.03)';
        ctx.fillRect(x - pad, 0, laneWidth * 0.84, canvas.height);

        if (i < state.laneCount - 1) {
          ctx.strokeStyle = 'rgba(255,255,255,0.08)';
          ctx.setLineDash([16, 16]);
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + pad, 0);
          ctx.lineTo(x + pad, canvas.height);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
    };

    const drawMotionLines = (dt) => {
      const stripeCount = 8;
      const stripeHeight = canvas.height / stripeCount;
      const offset = (state.distance * 0.3) % stripeHeight;
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 2;
      for (let i = 0; i < stripeCount + 1; i++) {
        const y = i * stripeHeight + offset;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y + stripeHeight * 0.4);
        ctx.stroke();
      }
    };

    const drawPlayer = () => {
      const laneX = state.lanes[state.player.lane];
      const ground = canvas.height - 120;
      const y = ground - state.player.y;
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(laneX, ground + 26, state.player.width * 0.55, 12, 0, 0, Math.PI * 2);
      ctx.fill();

      const gradient = ctx.createLinearGradient(laneX - 20, y - state.player.height, laneX + 20, y + state.player.height);
      gradient.addColorStop(0, '#06d6a0');
      gradient.addColorStop(1, '#118ab2');
      ctx.fillStyle = gradient;
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(laneX - state.player.width / 2, y - state.player.height, state.player.width, state.player.height, 12);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#ffd166';
      ctx.fillRect(laneX - 6, y - state.player.height + 14, 12, 18);
    };

    const drawObstacles = () => {
      const ground = canvas.height - 120;
      ctx.lineWidth = 2;
      state.obstacles.forEach((obs) => {
        const laneX = state.lanes[obs.lane];
        const y = obs.y + ground;
        ctx.fillStyle = obs.color;
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.beginPath();
        ctx.roundRect(laneX - obs.width / 2, y - obs.height, obs.width, obs.height, 10);
        ctx.fill();
        ctx.stroke();
      });
    };

    const drawCoins = () => {
      const ground = canvas.height - 120;
      state.coins.forEach((coin) => {
        const laneX = state.lanes[coin.lane];
        const y = coin.y + ground - 30;
        const radius = coin.size / 2;
        const shine = Math.abs(Math.sin(coin.spin)) * 0.35 + 0.6;
        const gradient = ctx.createRadialGradient(laneX, y, radius * 0.2, laneX, y, radius);
        gradient.addColorStop(0, `rgba(255, 209, 102, ${shine})`);
        gradient.addColorStop(1, 'rgba(255, 209, 102, 0.9)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.ellipse(laneX, y, radius, radius * 0.72, 0, 0, Math.PI * 2);
        ctx.fill();
      });
    };

    const update = (dt) => {
      const ground = canvas.height - 120;
      state.distance += state.speed * dt;
      state.speed = Math.min(760, state.speed + dt * 24);

      state.spawnTimer -= dt;
      if (state.spawnTimer <= 0) {
        spawnObstacle();
        state.spawnTimer = Math.max(0.5, 1.3 - state.speed / 1200);
      }

      state.coinTimer -= dt;
      if (state.coinTimer <= 0) {
        spawnCoin();
        state.coinTimer = 0.6 + Math.random() * 0.8;
      }

      // Player physics
      state.player.vy += state.player.gravity * dt;
      state.player.y += state.player.vy * dt;
      if (state.player.y > 0) {
        state.player.y = 0;
        state.player.vy = 0;
      }

      const speed = state.speed * dt;
      state.obstacles.forEach((obs) => { obs.y += speed; });
      state.coins.forEach((coin) => { coin.y += speed; coin.spin += dt * 8; });

      state.obstacles = state.obstacles.filter((obs) => obs.y + ground - obs.height < canvas.height + 40);
      state.coins = state.coins.filter((coin) => coin.y + ground - 20 < canvas.height + 30 && !coin.collected);

      // Collisions
      const playerX = state.lanes[state.player.lane];
      const playerY = ground - state.player.y;
      const playerTop = playerY - state.player.height;
      const playerBottom = playerY;
      const playerHalfW = state.player.width / 2;

      for (const obs of state.obstacles) {
        if (obs.lane !== state.player.lane) continue;
        const obsY = obs.y + ground;
        const obsTop = obsY - obs.height;
        const obsBottom = obsY;
        const horizontalHit = Math.abs(playerX - state.lanes[obs.lane]) < playerHalfW + obs.width / 2 - 6;
        const verticalHit = playerBottom > obsTop && playerTop < obsBottom && state.player.y <= obs.height * 0.65;
        if (horizontalHit && verticalHit) {
          state.gameOver = true;
          state.running = false;
          statusEl.textContent = 'You tripped! Press R to restart.';
          toast.textContent = 'Game over – press R to run again.';
        }
      }

      for (const coin of state.coins) {
        if (coin.collected) continue;
        if (coin.lane !== state.player.lane) continue;
        const coinY = coin.y + ground - 30;
        const withinY = coinY > playerTop - 12 && coinY < playerBottom + 8;
        const withinX = Math.abs(playerX - state.lanes[coin.lane]) < playerHalfW + coin.size * 0.4;
        if (withinX && withinY) {
          coin.collected = true;
          state.distance += 120;
          toast.textContent = 'Coin collected!';
        }
      }

      scoreEl.textContent = `Score: ${Math.floor(state.distance / 10)}`;
    };

    const loop = (timestamp) => {
      if (!state.running) return;
      const dt = Math.min(0.033, (timestamp - state.lastTime) / 1000);
      state.lastTime = timestamp;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawLanes();
      drawMotionLines(dt);
      drawCoins();
      drawObstacles();
      drawPlayer();
      update(dt);

      requestAnimationFrame(loop);
    };

    resize();
    resetGame();
  </script>
</body>
</html>
